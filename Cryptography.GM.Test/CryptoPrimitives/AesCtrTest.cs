using System;
using System.Linq;
using System.Security.Cryptography;
using Cryptography.GM.Primitives;
using Xunit;

namespace Cryptography.GM.Test.CryptoPrimitives;

public class AesCtrTest
{
    [Theory]
    [InlineData(new byte[]{0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
                new byte[]{0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff},
                new byte[]{0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a},
                new byte[]{0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51},
                new byte[]{0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef},
                new byte[]{0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10},
                new byte[]{0x87,0x4d,0x61,0x91,0xb6,0x20,0xe3,0x26,0x1b,0xef,0x68,0x64,0x99,0x0d,0xb6,0xce},
                new byte[]{0x98,0x06,0xf6,0x6b,0x79,0x70,0xfd,0xff,0x86,0x17,0x18,0x7b,0xb9,0xff,0xfd,0xff},
                new byte[]{0x5a,0xe4,0xdf,0x3e,0xdb,0xd5,0xd3,0x5e,0x5b,0x4f,0x09,0x02,0x0d,0xb0,0x3e,0xab},
                new byte[]{0x1e,0x03,0x1d,0xda,0x2f,0xbe,0x03,0xd1,0x79,0x21,0x70,0xa0,0xf3,0x00,0x9c,0xee})]
    public void TestAesCtr(byte[] key, byte[] iv,
                           byte[] p1, byte[] p2, byte[] p3, byte[] p4,
                           byte[] c1, byte[] c2, byte[] c3, byte[] c4)
    {
        using var aes = Aes.Create();
        aes.Key = key;
        aes.Mode = CipherMode.ECB;
        using var aesXfrm = aes.CreateEncryptor();
        using var xfrm = new CtrTransform(aesXfrm, iv);
        var buf = new byte[16];
        Assert.Equal(7, xfrm.TransformBlock(p1, 0, 7, buf, 0));
        Assert.Equal(9, xfrm.TransformBlock(p1, 7, 9, buf, 7));
        Assert.Equal(buf, c1);
        Assert.Equal(8, xfrm.TransformBlock(p2, 0, 8, buf, 0));
        Assert.Equal(8, xfrm.TransformBlock(p2, 8, 8, buf, 8));
        Assert.Equal(buf, c2);
        Assert.Equal(4, xfrm.TransformBlock(p3, 0, 4, buf, 0));
        Assert.Equal(12, xfrm.TransformBlock(p3, 4, 12, buf, 4));
        Assert.Equal(buf, c3);
        Assert.Equal(6, xfrm.TransformBlock(p4, 0, 6, buf, 0));
        Assert.Equal(10, xfrm.TransformBlock(p4, 6, 10, buf, 6));
        Assert.Equal(buf, c4);
        Assert.Equal(EmptyArray<byte>.Instance, xfrm.TransformFinalBlock(EmptyArray<byte>.Instance, 0, 0));
        Assert.Equal(16, xfrm.TransformBlock(c1, 0, 16, buf, 0));
        Assert.Equal(p1, buf);
        Assert.Equal(16, xfrm.TransformBlock(c2, 0, 16, buf, 0));
        Assert.Equal(p2, buf);
        Assert.Equal(16, xfrm.TransformBlock(c3, 0, 16, buf, 0));
        Assert.Equal(p3, buf);
        Assert.Equal(p4, xfrm.TransformFinalBlock(c4, 0, 16));

        for (var i = 0; i < 8; i++)
            xfrm.TransformBits(c1, buf, 9);

        xfrm.TransformBits(c1.AsSpan(9), buf.AsSpan(9), (16 - 9) * 8);
        Assert.Equal(p1.Skip(9), buf.Skip(9));
    }
}
